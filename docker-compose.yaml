version: '3.8'

services:

  kafka:
    image: apache/kafka
    container_name: kafka
    ports:
      # Порт 29092 для подключения с хост-машины (снаружи Docker)
      - "29092:29092"
    environment:
      # Настройки KRaft
      KAFKA_PROCESS_ROLES: 'broker,controller'
      KAFKA_NODE_ID: 1
      KAFKA_CONTROLLER_QUORUM_VOTERS: '1@kafka:9093'
      KAFKA_CONTROLLER_LISTENER_NAMES: 'CONTROLLER'

      # Карта "слушателей"
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: 'CONTROLLER:PLAINTEXT,INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT'

      # "Слушатели": какие порты Kafka слушает внутри своего контейнера
      # INTERNAL - для связи между контейнерами (ваш t1_api)
      # EXTERNAL - для связи с хост-машиной
      KAFKA_LISTENERS: 'INTERNAL://:9092,EXTERNAL://:29092,CONTROLLER://:9093'

      # "Рекламируемые слушатели": адреса, которые Kafka сообщает клиентам
      # Клиент, подключившийся к INTERNAL, будет направлен на kafka:9092
      # Клиент, подключившийся к EXTERNAL, будет направлен на localhost:29092
      KAFKA_ADVERTISED_LISTENERS: 'INTERNAL://kafka:9092,EXTERNAL://localhost:29092'
      
      # Указываем, какой listener использовать для межброкерного общения
      KAFKA_INTER_BROKER_LISTENER_NAME: 'INTERNAL'

      # Прочие настройки
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_LOG_RETENTION_HOURS: 168  # 7 дней
      KAFKA_LOG_RETENTION_BYTES: 1073741824  # 1GB на партицию
      KAFKA_COMPRESSION_TYPE: 'gzip'
      KAFKA_MAX_REQUEST_SIZE: 10485760  # 10MB
      # Cluster ID - Из переменной окружения
      CLUSTER_ID: ${KAFKA_CLUSTER_ID:-J1HdvnRXS8qb0jsjNlvmnQ}
    healthcheck:
      test: ["CMD-SHELL", "/opt/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list || exit 1"]
      interval: 15s
      timeout: 10s
      retries: 10
      start_period: 40s
    volumes:
      - kafka_data:/var/lib/kafka/data

  redis:
    image: redis:7-alpine
    container_name: t1_redis
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    volumes:
      - redis_data:/data

  minio:
    image: minio/minio:latest
    container_name: t1_minio
    ports:
      - "9000:9000"  # API
      - "9001:9001"  # Console UI
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin123}
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 10s
      timeout: 5s
      retries: 5
    volumes:
      - minio_data:/data

  minio-init:
    image: minio/mc:latest
    container_name: t1_minio_init
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set minio http://minio:9000 ${MINIO_ROOT_USER:-minioadmin} ${MINIO_ROOT_PASSWORD:-minioadmin123};
      mc mb minio/tech-support --ignore-existing;
      mc anonymous set download minio/tech-support;
      echo 'Minio bucket created successfully';
      "
    restart: on-failure

  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: t1_api
    depends_on:
      kafka:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
      bot:
        condition: service_started
      "message-saver":
        condition: service_started
    ports:
      - "8000:8000"
      - "8001:8001"  # Prometheus metrics endpoint
    env_file:
      - .env
    environment:
      - HOST=0.0.0.0
      - PORT=8000
      - RELOAD=True
      - KAFKA_URL=kafka:9092
      - REDIS_URL=redis://redis:6379
      - S3_ENDPOINT_URL=http://minio:9000
      - S3_PUBLIC_URL=http://localhost:9000
      - S3_ACCESS_KEY=${MINIO_ROOT_USER:-minioadmin}
      - S3_SECRET_KEY=${MINIO_ROOT_PASSWORD:-minioadmin123}
      - S3_BUCKET_NAME=tech-support
      - ML_SERVICE_URL=http://ml:8004
    volumes:
      - ./backend:/app
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  celery-worker:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: t1_celery_worker
    command: celery -A app.celery_app worker --loglevel=info --concurrency=4
    depends_on:
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - KAFKA_URL=kafka:9092
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./backend:/app

  celery-beat:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: t1_celery_beat
    command: celery -A app.celery_app beat --loglevel=info
    depends_on:
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./backend:/app
  
  bot:
    build:
      context: ./telegram
      dockerfile: Dockerfile
    container_name: t1_bot
    env_file:
      - .env
    environment:
      - BACKEND_API_URL=http://api:8000
      - KAFKA_URL=kafka:9092
    depends_on:
      kafka:
        condition: service_healthy
    volumes:
      - ./telegram:/app

  message-saver:
    build:
      context: ./message_saver
      dockerfile: Dockerfile
    container_name: t1_saver
    env_file:
      - .env
    environment:
      - KAFKA_URL=kafka:9092
    depends_on:
      kafka:
        condition: service_healthy
    volumes:
      - ./message_saver:/app
  notification-service:
    build:
      context: ./notification_service
      dockerfile: Dockerfile
    container_name: t1_notification
    env_file:
      - .env
    depends_on:
      kafka:
        condition: service_healthy
    ports:
      - "8002:8002"
      
  stats-service:
    build:
      context: ./stats_service
      dockerfile: Dockerfile
    container_name: t1_stats
    env_file:
      - .env
    depends_on:
      kafka:
        condition: service_healthy
    ports:
      - "8003:8003"
  
  summarizer:
    build:
      context: ./summarizer
      dockerfile: Dockerfile
    container_name: t1_summarizer
    env_file:
      - .env
    environment:
      - KAFKA_URL=kafka:9092
      # MONGODB_URL берется из .env (удаленная MongoDB)
    depends_on:
      kafka:
        condition: service_healthy
    volumes:
      - ./summarizer:/app
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: t1_frontend
    ports:
      - "3001:80"
    depends_on:
      - api
    restart: unless-stopped

  promtail:
    image: grafana/promtail:latest
    container_name: promtail
    ports:
      - "9080:9080"
    volumes:
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock
      - ./promtail-config.yaml:/etc/promtail/config.yml
    command: -config.file=/etc/promtail/config.yml
    privileged: true

  loki:
    image: grafana/loki:latest
    container_name: loki
    ports:
      - "3100:3100"
    volumes:
      - ./loki-config.yaml:/etc/loki/local-config.yaml

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheusdata:/prometheus

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./grafana/datasources.yaml:/etc/grafana/provisioning/datasources/datasources.yaml
      - grafanadata:/var/lib/grafana

  qdrant:
    image: qdrant/qdrant:latest
    container_name: qdrant
    restart: unless-stopped
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - ./qdrant_storage:/qdrant/storage:z 

  qdrant-init:
    build:
      context: ./support-hints-agent-system
      dockerfile: Dockerfile
    container_name: qdrant-init
    environment:
      - QDRANT_URL=http://qdrant:6333
    env_file:
      - .env
    depends_on:
      qdrant:
        condition: service_started
    command: python init_qdrant.py
    restart: "no"

  ml:
    build:
      context: ./support-hints-agent-system
      dockerfile: Dockerfile
    container_name: ml-agent-container
    restart: unless-stopped
    ports:
      - "8004:8004"
    environment:
      - QDRANT_URL=http://qdrant:6333
    env_file:
      - .env
    depends_on:
      - qdrant-init

volumes:
  kafka_data:
  redis_data:
  prometheus_data:
  grafana_data:
  minio_data:
  grafanadata:
  prometheusdata:
  qdrant_storage:
