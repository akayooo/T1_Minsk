# Настройка сервисов и API

В этом документе описаны шаги для развертывания зависимостей, таких как векторная база данных Qdrant, и приведено описание эндпоинтов API.

## 1. Настройка векторной базы данных Qdrant

Система использует Qdrant для хранения векторов знаний и долгосрочной памяти. Рекомендуемый способ запуска — через Docker.

### Запуск с помощью Docker

1.  **Загрузите образ Qdrant:**

    ```bash
    docker pull qdrant/qdrant
    ```

2.  **Запустите контейнер:**

    Эта команда запустит Qdrant и создаст директорию `qdrant_storage` в вашем проекте для персистентного хранения данных.

    ```bash
    docker run -p 6333:6333 \
      -v "$(pwd)/qdrant_storage:/qdrant/storage" \
      qdrant/qdrant:latest
    ```

После запуска Qdrant будет доступен по адресу `http://localhost:6333`.

## 2. Создание коллекций в Qdrant

После запуска Qdrant необходимо создать две коллекции с правильными параметрами векторов и индексами. Для этого в проекте есть специальный скрипт.

-   `knowledge_base` — для хранения документов базы знаний (использует гибридный поиск).
-   `long_term_memory` — для хранения извлеченных из диалогов фактов о пользователях.

Запустите скрипт следующей командой из корневой директории проекта:

```bash
python -m agent_system.service.qudrant_db_creator
```

Скрипт автоматически подключится к Qdrant и создаст или пересоздаст необходимые коллекции.

## 3. Документация по API

Сервер API реализован на FastAPI и предоставляет пять основных эндпоинтов для работы с системой поддержки.

---

### 3.1. `POST /memorize`

**Назначение:** Извлечение знаний из диалога между клиентом и оператором, дедупликация и сохранение в долгосрочную память (long-term memory).

Этот эндпоинт анализирует диалог, извлекает важные факты о пользователе (предпочтения, проблемы, контекст) и сохраняет их в векторной базе данных для последующего использования в персонализированных подсказках.

#### Тело запроса (`MemorizeRequest`)

```json
{
  "user_id": 12345,
  "dialogue": [
    {
      "role": "client",
      "content": "Здравствуйте, я хочу открыть вклад на 6 месяцев"
    },
    {
      "role": "operator",
      "content": "Отлично! Какую сумму вы планируете разместить?"
    },
    {
      "role": "client",
      "content": "Около 500 тысяч рублей"
    }
  ]
}
```

**Параметры:**
- **`user_id`** (integer, обязательный): Уникальный идентификатор пользователя.
- **`dialogue`** (array, обязательный): Последовательность сообщений диалога. Каждое сообщение содержит:
  - **`role`** (string): Роль отправителя (`"client"`, `"operator"`, `"user"` и т.д.)
  - **`content`** (string): Текст сообщения

#### Тело ответа

**Успешное сохранение:**
```json
{
  "message": "3 new knowledge items have been successfully saved."
}
```

**Нет новых знаний:**
```json
{
  "message": "Dialogue processed. No new unique knowledge was found to save."
}
```

#### Коды ответа
- **200 OK**: Диалог успешно обработан
- **503 Service Unavailable**: Контроллеры не инициализированы
- **500 Internal Server Error**: Ошибка при обработке диалога

#### Пример использования

```bash
curl -X POST "http://localhost:8000/memorize" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 12345,
    "dialogue": [
      {"role": "client", "content": "Хочу открыть вклад"},
      {"role": "operator", "content": "На какой срок?"},
      {"role": "client", "content": "На 6 месяцев"}
    ]
  }'
```

---

### 3.2. `POST /slice-document`

**Назначение:** Обработка текстовых фрагментов документа, создание структурированных фрагментов знаний и сохранение их в базу знаний (knowledge base).

Этот эндпоинт используется для загрузки документации, FAQ, инструкций и других материалов в систему. Текст разбивается на логические фрагменты, каждому присваивается заголовок и метаданные.

#### Тело запроса (`SlicingRequest`)

```json
{
  "text_chunks": [
    "Для открытия вклада необходимо предоставить паспорт и ИНН.",
    "Минимальная сумма вклада составляет 10 000 рублей.",
    "Процентная ставка зависит от срока размещения средств."
  ],
  "source": "vtb_deposits_faq"
}
```

**Параметры:**
- **`text_chunks`** (array of strings, обязательный): Последовательность текстовых фрагментов документа
- **`source`** (string, обязательный): Название источника документа (используется для фильтрации и отслеживания)

#### Тело ответа

**Успешное сохранение:**
```json
{
  "message": "15 new knowledge fragments from 'vtb_deposits_faq' saved."
}
```

**Нет валидных фрагментов:**
```json
{
  "message": "Document processed, but no valid fragments were created."
}
```

#### Коды ответа
- **200 OK**: Документ успешно обработан и сохранен
- **503 Service Unavailable**: RetrieverController не инициализирован
- **500 Internal Server Error**: Ошибка при обработке документа

#### Пример использования

```bash
curl -X POST "http://localhost:8000/slice-document" \
  -H "Content-Type: application/json" \
  -d '{
    "text_chunks": [
      "Для открытия счета нужен паспорт",
      "Минимальная сумма - 1000 рублей"
    ],
    "source": "banking_faq"
  }'
```

---

### 3.3. `POST /search`

**Назначение:** Поиск наиболее релевантного документа из базы знаний по текстовому запросу.

Этот эндпоинт выполняет гибридный поиск (комбинация dense и sparse векторов) и возвращает только топ-1 самый релевантный документ. Используется для быстрого получения ответа на конкретный вопрос.

#### Тело запроса (`SearchRequest`)

```json
{
  "query": "Как открыть вклад в банке?"
}
```

**Параметры:**
- **`query`** (string, обязательный): Поисковый запрос

#### Тело ответа (`SearchResponse`)

**Документ найден:**
```json
{
  "document": {
    "id": "42",
    "score": 0.8734,
    "payload": {
      "knowledge": "Для открытия вклада необходимо предоставить паспорт, ИНН и заполнить заявление. Минимальная сумма вклада - 10 000 рублей.",
      "title": "Открытие вклада",
      "sub_title": "Требования и документы",
      "source": "vtb_deposits_faq",
      "id": 42
    }
  },
  "message": null
}
```

**Документ не найден:**
```json
{
  "document": null,
  "message": "No relevant documents found."
}
```

**Поля ответа:**
- **`document`** (object, nullable): Найденный документ
  - **`id`** (string): Уникальный идентификатор документа
  - **`score`** (float, nullable): Оценка релевантности (0.0 - 1.0, чем выше - тем релевантнее)
  - **`payload`** (object): Содержимое документа
    - **`knowledge`** (string): Основной текст знания
    - **`title`** (string): Заголовок
    - **`sub_title`** (string): Подзаголовок
    - **`source`** (string): Источник документа
    - **`id`** (integer): Внутренний ID
- **`message`** (string, nullable): Сообщение, если документ не найден

#### Коды ответа
- **200 OK**: Поиск выполнен успешно
- **503 Service Unavailable**: RetrieverController не инициализирован
- **500 Internal Server Error**: Ошибка при выполнении поиска

#### Особенности поиска
- Использует **гибридный поиск**: комбинация dense embeddings (семантическая близость) и sparse vectors (BM25, лексическая близость)
- Применяет **Reciprocal Rank Fusion** для объединения результатов
- Возвращает только **топ-1** результат с наивысшей релевантностью

#### Пример использования

```bash
curl -X POST "http://localhost:8000/search" \
  -H "Content-Type: application/json" \
  -d '{"query": "Как открыть вклад?"}'
```

```python
import requests

response = requests.post(
    "http://localhost:8000/search",
    json={"query": "Как заблокировать карту?"}
)

result = response.json()
if result['document']:
    print(f"Найдено: {result['document']['payload']['knowledge']}")
    print(f"Релевантность: {result['document']['score']:.2%}")
```

---

### 3.4. `POST /assist`

**Назначение:** Получение подсказок для оператора на основе запроса пользователя и контекста диалога.

Этот эндпоинт является основным для работы системы помощи оператору. Он анализирует запрос клиента, находит релевантные документы, генерирует подсказки и рекомендации для оператора через агентную систему с использованием LLM.

#### Тело запроса (`AssistRequest`)

```json
{
  "user_request": "Не могу войти в аккаунт, пишет Invalid credentials",
  "last_messages": [
    {
      "role": "client",
      "content": "Здравствуйте, у меня проблема с входом"
    },
    {
      "role": "operator",
      "content": "Расскажите подробнее о проблеме"
    }
  ]
}
```

**Параметры:**
- **`user_request`** (string, обязательный): Текущий запрос или сообщение пользователя
- **`last_messages`** (array, опциональный): До 10 последних сообщений диалога для контекста. Каждое сообщение содержит:
  - **`role`** (string): Роль отправителя (`"client"` или `"operator"`)
  - **`content`** (string): Текст сообщения

#### Тело ответа (`AssistResponse`)

```json
{
  "hints": {
    "suggested_actions": [
      "Попросите клиента проверить правильность ввода логина и пароля.",
      "Предложите воспользоваться функцией восстановления пароля.",
      "Уточните, не заблокирован ли аккаунт после нескольких неудачных попыток входа."
    ],
    "key_points": [
      "Ошибка 'Invalid credentials' указывает на неверные учетные данные",
      "Возможна блокировка после 5 неудачных попыток"
    ],
    "recommended_response": "Давайте проверим правильность введенных данных. Попробуйте восстановить пароль через форму на сайте."
  },
  "relevant_docs": [
    {
      "id": "123",
      "score": 0.91,
      "payload": {
        "knowledge": "Для входа в аккаунт используйте зарегистрированный email и пароль. При забытом пароле воспользуйтесь функцией восстановления.",
        "title": "Инструкция по входу в аккаунт",
        "sub_title": "Как получить доступ к аккаунту",
        "source": "KB_docs",
        "id": 123
      }
    },
    {
      "id": "124",
      "score": 0.87,
      "payload": {
        "knowledge": "После 5 неудачных попыток входа аккаунт блокируется на 30 минут для безопасности.",
        "title": "Безопасность аккаунта",
        "sub_title": "Блокировка при неудачных попытках входа",
        "source": "KB_docs",
        "id": 124
      }
    }
  ],
  "debug": {
    "iteration_count": 2,
    "controller_satisfactory": true
  }
}
```

**Поля ответа:**
- **`hints`** (object): Сгенерированные подсказки для оператора
  - **`suggested_actions`** (array): Рекомендуемые действия
  - **`key_points`** (array): Ключевые моменты для понимания ситуации
  - **`recommended_response`** (string): Рекомендуемый ответ клиенту
- **`relevant_docs`** (array): Топ-3 наиболее релевантных документа из базы знаний
  - **`id`** (string): ID документа
  - **`score`** (float, nullable): Оценка релевантности
  - **`payload`** (object): Содержимое документа
- **`debug`** (object, optional): Отладочная информация
  - **`iteration_count`** (integer): Количество итераций агентной системы
  - **`controller_satisfactory`** (boolean): Оценка качества ответа внутренним контроллером

#### Коды ответа
- **200 OK**: Подсказки успешно сгенерированы
- **503 Service Unavailable**: Система не инициализирована
- **500 Internal Server Error**: Ошибка при обработке запроса

#### Особенности работы
- Использует **агентную систему** с несколькими специализированными агентами
- Выполняет **RAG (Retrieval-Augmented Generation)** для поиска релевантной информации
- Применяет **контроллер качества** для оценки и улучшения ответов
- Поддерживает **итеративную генерацию** для повышения качества подсказок

#### Пример использования

```bash
curl -X POST "http://localhost:8000/assist" \
  -H "Content-Type: application/json" \
  -d '{
    "user_request": "Как открыть вклад?",
    "last_messages": [
      {"role": "client", "content": "Здравствуйте"},
      {"role": "operator", "content": "Чем могу помочь?"}
    ]
  }'
```

```python
import requests

response = requests.post(
    "http://localhost:8000/assist",
    json={
        "user_request": "Не могу войти в интернет-банк",
        "last_messages": [
            {"role": "client", "content": "Помогите с входом"},
            {"role": "operator", "content": "Какая ошибка?"}
        ]
    }
)

result = response.json()
print("Подсказки:", result['hints'])
print("Релевантные документы:", len(result['relevant_docs']))
```

---

### 3.5. `POST /classifier`

**Назначение:** Классификация вопроса пользователя по основной категории и подкатегории.

Этот эндпоинт использует дообученные модели DeepPavlov BERT для автоматической классификации вопросов клиентов. Сначала определяется основная категория вопроса, затем на основе неё определяется подкатегория. Это помогает быстро направить запрос в нужный отдел или подобрать релевантные шаблоны ответов.

#### Тело запроса (`CategoryPredictRequest`)

```json
{
  "question": "Как открыть вклад на выгодных условиях?"
}
```

**Параметры:**
- **`question`** (string, обязательный): Текст вопроса для классификации

#### Тело ответа (`CategoryPredictResponse`)

```json
{
  "main_category": "Вклады и накопления",
  "subcategory": "Открытие вклада"
}
```

**Поля ответа:**
- **`main_category`** (string): Предсказанная основная категория вопроса
- **`subcategory`** (string): Предсказанная подкатегория вопроса

#### Коды ответа
- **200 OK**: Классификация выполнена успешно
- **400 Bad Request**: Ошибка валидации входных данных
- **500 Internal Server Error**: Ошибка при выполнении классификации

#### Особенности работы
- Использует **fine-tuned DeepPavlov BERT модели** для русского языка
- Двухэтапная классификация: сначала основная категория, затем подкатегория
- Модели обучены на специфичных для банковской поддержки данных

#### Пример использования

```bash
curl -X POST "http://localhost:8000/classifier" \
  -H "Content-Type: application/json" \
  -d '{"question": "Не могу войти в мобильное приложение"}'
```

```python
import requests

response = requests.post(
    "http://localhost:8000/classifier",
    json={"question": "Как заблокировать карту при утере?"}
)

result = response.json()
print(f"Категория: {result['main_category']}")
print(f"Подкатегория: {result['subcategory']}")
```

---

## 4. Интерактивная документация

После запуска API сервера доступна автоматическая интерактивная документация:

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

В Swagger UI можно протестировать все эндпоинты прямо в браузере.

---

## 5. Примеры использования

### Полный workflow

```python
import requests

API_URL = "http://localhost:8000"

# 1. Загрузка документов в базу знаний
requests.post(f"{API_URL}/slice-document", json={
    "text_chunks": ["Текст документа 1", "Текст документа 2"],
    "source": "faq_v1"
})

# 2. Классификация вопроса
classifier_result = requests.post(f"{API_URL}/classifier", json={
    "question": "Как открыть вклад на выгодных условиях?"
}).json()

print(f"Категория: {classifier_result['main_category']}")
print(f"Подкатегория: {classifier_result['subcategory']}")

# 3. Поиск информации
search_result = requests.post(f"{API_URL}/search", json={
    "query": "Как открыть счет?"
}).json()

print(f"Найдено: {search_result['document']['payload']['knowledge']}")

# 4. Получение подсказок для оператора
assist_result = requests.post(f"{API_URL}/assist", json={
    "user_request": "Хочу открыть вклад",
    "last_messages": []
}).json()

print(f"Подсказки: {assist_result['hints']}")

# 5. Сохранение диалога в память
requests.post(f"{API_URL}/memorize", json={
    "user_id": 123,
    "dialogue": [
        {"role": "client", "content": "Хочу открыть вклад"},
        {"role": "operator", "content": "На какой срок?"},
        {"role": "client", "content": "На 6 месяцев"}
    ]
})
```

---

## 6. Обработка ошибок

Все эндпоинты возвращают стандартные HTTP коды ошибок:

- **400 Bad Request**: Неверный формат запроса
- **422 Unprocessable Entity**: Ошибка валидации данных
- **500 Internal Server Error**: Внутренняя ошибка сервера
- **503 Service Unavailable**: Сервис временно недоступен

Пример ответа с ошибкой:
```json
{
  "detail": "An unexpected error occurred during dialogue processing: Connection timeout"
}
```
